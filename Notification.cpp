#include "Notification.h"

Notification::Notification()
{
}

void Notification::sendUDPNotification(EthernetUDP &udpSocket, aJsonObject *pushurl_channel, char *payload1, extData payload2)
{
  Serial.print(F("Sending a UDP response: "));
  Serial.println(payload1);

  udpSocket.beginPacket(udpSocket.remoteIP(), udpSocket.remotePort());

  // The actual payload
  udpSocket.write(payload1);

  // Extra payload is generated by running a callback function
  if (payload2 != NULL)
  {
    (*payload2)(&udpSocket);
  }

  udpSocket.write("}"); // The end of the JSON data, i.e. '}'
  udpSocket.endPacket();
}

void Notification::sendWPNotification(aJsonObject *pushurl_channel, char *payload1, extData payload2, int notificationType)
{
  EthernetClient tcpSocket;

  // The channel is in form 'host:port:path'
  // Break it down in place to save precious RAM
  char *host = pushurl_channel->valuestring;
  char *port = strchr(host, ':');
  port[0] = '\0';
  port++;
  char *path = strchr(port, ':');
  path[0] = '\0';
  path++;

  if (tcpSocket.connect(host, atoi(port)) != true ) {
    Serial.println(F("Failed to connect to PUSH channel"));
    return;
  }

  // HTTP header, note the notification headers
  tcpSocket.print(F("POST "));
  tcpSocket.print(path);
  tcpSocket.print(F(" HTTP/1.1\r\n"));

  tcpSocket.print(F("Host: "));
  tcpSocket.print(Ethernet.localIP());
  tcpSocket.print(F("\r\nUser-Agent: Arduino/1.0\r\n"));
  tcpSocket.print(F("Content-Type: text/xml\r\n"));
  tcpSocket.print(F("Connection: close\r\n"));

  // Only 'tile' or 'toast' notifications use the 'X-WindowsPhone-Target' header
  if (notificationType < 3)
  {
    tcpSocket.print(F("X-WindowsPhone-Target: "));

    switch (notificationType)
    {
      case 1: // Tile notification
        tcpSocket.print(F("token\r\n"));
        break;
      case 2: // Toast notification
        tcpSocket.print(F("toast\r\n"));
        break;
    }
  }

  tcpSocket.print(F("X-NotificationClass: "));
  tcpSocket.print(notificationType);
  tcpSocket.print(F("\r\n"));

  int payload2Bytes = 0;

  // Extra payload is generated by running a callback function
  // First run - just get the number of bytes
  if (payload2 != NULL)
  {
    payload2Bytes = (*payload2)(NULL);
  }

  tcpSocket.print(F("Content-Length: "));
  if (payload2 == NULL) {
    tcpSocket.print(strlen(payload1) + 1);
  } else {
   tcpSocket.print(strlen(payload1) + payload2Bytes + 2);
  }

  tcpSocket.print("\r\n\r\n");

  // The actual payload
  tcpSocket.print(payload1);

  // Extra payload is generated by running a callback function
  if (payload2 != NULL)
  {
    (*payload2)(&tcpSocket);
  }

  tcpSocket.print("}"); // The end of the JSON data, i.e. '}'

  Serial.println(F("Payload sent:\n---"));
  Serial.println(payload1);

  // Print out the HTTP request response
  Serial.println(F("Response:\n---"));
  while (tcpSocket.connected()) {
    while (tcpSocket.available()) {
      char c = tcpSocket.read();
      Serial.print(c);
    }
  }

  tcpSocket.stop();
}
